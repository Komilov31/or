# Пакет Done - Функция Or

## Описание

Пакет `done` предоставляет утилитарную функцию `Or`, которая объединяет несколько каналов завершения (`<-chan interface{}`) в один общий канал завершения. Возвращаемый канал закрывается, как только закроется **любой** из входных каналов, позволяя одному слушателю ожидать первого сигнала завершения от нескольких источников. Это особенно полезно в параллельных программах на Go для агрегирования сигналов отмены или завершения без блокировки на всех операциях.

Функция обрабатывает граничные случаи:
- Ноль каналов: Возвращает канал, который закрывается немедленно.
- Один канал: Возвращает входной канал напрямую.
- Несколько каналов: Использует рекурсию и `select` для ожидания первого сигнала закрытия.

Пакет реализован на Go и включает всесторонние тесты для различных сценариев, включая отложенные закрытия, nil-каналы и множественные входы.


## Использование

Импортируйте пакет как `done`:

```go
import "github.com/Komilov31/or"
```

### Сигнатура функции

```go
func Or(channels ...<-chan interface{}) <-chan interface{}
```

- **Вход**: Список каналов завершения (`<-chan interface{}`) переменной длины.
- **Выход**: Один канал завершения, который закрывается, когда закрывается любой входной канал.

### Примеры

#### Пример 1: Объединение двух каналов (первый закрывается немедленно)

Этот пример показывает, как `Or` закрывается немедленно, когда первый канал уже закрыт.

```go
package main

import (
    "fmt"
    "time"

    "github.com/Komilov31/l2.14"
)

func main() {
    // Канал 1: Сразу закрываем
    c1 := make(chan interface{})
    close(c1)

    // Канал 2: Закрывается через 1 секунду
    c2 := make(chan interface{})
    go func() {
        time.Sleep(1 * time.Second)
        close(c2)
    }()

    merged := done.Or(c1, c2)
    <-merged // Блокируется до первого закрытия (немедленно из-за c1)
    fmt.Println("Объединенный канал закрыт")
}
```

Вывод: "Объединенный канал закрыт" печатается немедленно.

#### Пример 2: Ожидание самого быстрого из нескольких отложенных каналов

Здесь `Or` ожидает закрытия самого быстрого канала (50мс против 1с).

```go
package main

import (
    "fmt"
    "time"

    "github.com/Komilov31/l2.14"
)

func delayedClose(d time.Duration) <-chan interface{} {
    c := make(chan interface{})
    go func() {
        time.Sleep(d)
        close(c)
    }()
    return c
}

func main() {
    c1 := delayedClose(1 * time.Second) // Медленный
    c2 := delayedClose(50 * time.Millisecond) // Быстрый

    merged := done.Or(c1, c2)
    select {
    case <-merged:
        fmt.Println("Один из каналов закрылся (быстрый)")
    case <-time.After(2 * time.Second):
        fmt.Println("Таймаут")
    }
}
```

Вывод: "Один из каналов закрылся (быстрый)" печатается через ~50мс.

#### Пример 3: Ноль каналов (немедленное закрытие)

`Or` без каналов возвращает канал, который закрывается сразу.

```go
package main

import (
    "fmt"

    "github.com/Komilov31/l2.14"
)

func main() {
    merged := done.Or() // Нет каналов
    <-merged
    fmt.Println("Объединенный канал с нулем каналов закрыт немедленно")
}
```

Вывод: "Объединенный канал с нулем каналов закрыт немедленно" печатается немедленно.

#### Пример 4: Пропуск одного канала

С одним каналом `Or` просто возвращает его.

```go
package main

import (
    "fmt"
    "time"

    "github.com/Komilov31/l2.14"
)

func main() {
    c := make(chan interface{})
    go func() {
        time.Sleep(100 * time.Millisecond)
        close(c)
    }()

    merged := done.Or(c) // Пропуск
    <-merged
    fmt.Println("Один канал закрыт после задержки")
}
```

Вывод: "Один канал закрыт после задержки" печатается через 100мс.

## Тестирование

Запустите тесты с помощью:

```bash
go test -v
```